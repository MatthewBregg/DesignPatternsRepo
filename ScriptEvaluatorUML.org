
* What is needed....
** Driver
*** Argument parser
**** Possible arguments
- Parses inputs from command line
- Will use defaults if arguments missing.
  - Setting file. (Like .cardgenerator.cfg) -config_file=".cardgenerator.cfg"
    - Could specify all settings in here instead, defaults to looking for .cardgenerator in same directory
  - --help 
    - Print out help if passed in, and then quit program. 
  - -output-format="[png|jpg|pdf|etc]" (I'm leaving out SVG and any vector formats, that complicates design... Ignore them for now, not needed.
    - Set the format to output to. Defaults to pdf. 
  - -script-file="script.cards"
    - The script to run. Only one script file can be run, but this script file can reference other scripts.
  - output-dir="./"
    - Defaults to current directory.
    - Outputs created file here. Must already exist.
  - -logfile=".card_log"
    - Defaults to .card_log
    - Where to log errors/warning/notifications from parsing script/config.
  - -loglevel="[1|2|3|4|5]"
    - How much detail to log
      
**** Interface
- Driver query options object it returns.
- Most of these options should be handled by driver, this just parses it...
*** Image Renderer
- Maybe this will be a strategy?
- Takes the Image files given in, plus option object.
- Compose them into one sheet, cards should have front and backs next to each other, with the sides labelled, and the card name should be visible. 
- Convert to desire format. (EX, to jpg, png,pdf)
- Return the file
*** File reading
- Takes option object, and returns needed files.
*** File writing
- Takes option object, and output file, and writes it to given disk location. 
  
*** Main loop
- If any of these steps returns an error/warning, place the error/warning into the log file
  - and depending on the severity,
  - abort and print error, or continue, and print warning.
- Pass the args to the Argument Parser, hold onto option object.
- Retrieve the input files from File Reading
- Pass the input files into the ScriptEvaluator
- Retrieve a ArrayList of tuplets from ScriptEvaluator, each tuplet has front image, back image, card name.
- Send to Image Renderer
- Send output from Image Renderer to file writer, write to disk. (Maybe use visiter?)
- Done


** Object Creation builder
- Allows one to create objects from the scripting langauge cleanly.
  - Context sees it is making something new, sees what it is making from function.
  - Token comparison will have to happen some how, although could avoid a hard coded comparison...
  - A FooBuilder is made. 
  - For each argument in foo, if it's a simple variable, grab it, if a new object as well, recursively run this to make it, and then....
  - We store things as a broad supertype for all available types.
  - This type then takes in the FooBuilder, and call the addAsArgMyType(this)
    #+BEGIN_SRC java
//Bar was made from the arguments
class BarType {
//...Ellided stuff

void acceptBuilder(Builder builder) {
   buildee.addAsArgMyType(this);
}
    
    #+END_SRC
  - When all arguments are in the builder, do builder.getScriptObject(), returning a script object. 
  - If the builder was given arguments that it couldn't work with, then it will return null.
  
  - Why go through all this hassle?
  - Then we can store all objects the script makes in a map of strings -> scriptobject.
  - And then, when we reference them to create another object, we can do it without casting!
  - It's essentially combing builder + visiter.
  - This is instead of an abstract factory!
    - Because an abstract Factory doesn't actually make that much sense!
    - We aren't switching between families of types!
    - Factory method could work better than that I think?. 
      
#+BEGIN_SRC java
  //Null in this case, rather than using java null, might want to be
  //A special subclass of script object.
  //then we don't need null checks!
  //The null object can just propogate!
  //It would have ot hold it's error inside it.

  //For defines, the defines is given in as usually, a define builder is made,
  //The define builder will have to set the define, so builders will need
  //Access to the map of var names -> ScriptObjects

  //The parser makes the tokens.

  //eval-file is handled by making a new Parser, and assembler, and running that on the script, but passing in the existing global environment/anything else. 

  /**
     (VarName x y)
     (define (VarName x y) (function token))
     In both cases above, VarName is going to be parsed as an expression token.
     The difference will then be during evaluation....
     The token itself will attempt to look up the varname.
     So, for already defined functions, the builder will have been created.
     For undefined functions, returned undefined builder?
     And undefined builder will return an undefined function call block, which a
     define can then use to know, ok, I am making a function, make that function, and put it in the
     function builders!! The function builder won't be a singleton, but will be kept in the env!!
     Then when calling, the builder will retreive the function, whose builder will have stored
     the function body tokens.
     This builder then gets the arguments, input, makes a new env frame, and then calls the
     Script evaluator on the tokens given in.
     Then pop the stack frame!
     One problem, the tokens are already evaluated the former stage...

     Oh, and current design should have undefined varname.
     So, add 2 objs.
     Undefined varname
     Undefined function call
     Null script object

     Builder Factory will be in env...

     The two undefined* ScriptObjects will be made by the tokens.
     Upon seeing the respective map is only returning null, they will take name, put it in, and then in the case of function obj, all parameters
     will be in argument list. Returns that builder, lets the ScriptEvaluator add the args if needed, and then that builder returns the correct
     undefined object.
      
     

  ,**/

  class Builder {
      ScriptEvaluator eval = ...;
      void setScriptEvaluator(ScriptEvaluator eval) { 
          this.eval = eval;
      }
      //This will be the default method for this in Builder.
      //Very few things will override it, but the define builder will!
      //Define builder will say, ok,
      //First below as usual, then see if I get added a varname, or a undefined function block.
      //If undefined var name, then eval the body to get the ScriptObject, and then
      //set the top environment with the name,value pair
      //If a undefined function block, then make a new function builder.
      //Add to that function builder the parameters from the undefined function block. (A list)
      //The addToken function now no longer parses and accepts each token, instead add to
      //function builder
      //Then get the top env, and add it to the BuilderFactory.
      //Done!
      //When the expression token looks in the env::BuilderFactory for the correct builder, it will find
      //it!
      ScriptEvaluator getEval() {
          return eval;
      }
      void addToken(Token token) {
          ScriptObject obj = eval.doParse(token);
          obj.accept(this);

      }
            
            
  }

  class DefineBuilder {
      FunctionBuilder functionBuilder = null;
      State currentState = new UnknownState();
      ScriptObject var = new NullScriptObj();
      String name = "";
      //Define builder will say, ok,
      //First below as usual, then see if I get added a varname, or a undefined function block.
      //If undefined var name, then eval the body to get the ScriptObject, and then
      //set the top environment with the name,value pair
      //If a undefined function block, then make a new function builder.
      //Add to that function builder the parameters from the undefined function block. (A list)
      //The addToken function now no longer parses and accepts each token, instead add to
      //function builder
      //Then get the top env, and add it to the BuilderFactory.
      //Done!
      //When the expression token looks in the env::BuilderFactory for the correct builder, it will find
      //it!
      void addToken(Token token) {
          if ( currentState.equals(new UnknownState()) || currentState.equals(new variableState()) ) {
              ScriptObject obj = eval.doParse(token);
              obj.accept(this);
          }
          else if (currentState.equals(new FunctionState())){
              functionBuilder.add(token);
          }
      }
      void addUndefinedFunction(UndefinedFunction f) {
          if ( currentState.equals(new UnknownState()) ) {
              currentState = new FunctionState();
              functionBuilder = new FunctionBuilder(f.getFunctionName(),f.getFunctionParameters());
          }
          else {
              this.setVar(f);
          }
      }
      void addUndefinedVariableObject(UndefinedVariable v) {
          if ( currentState.equals(new UnkownState()) ) {
              currentState = new VarState();
              name = v.getName();
          } else {
              this.setVar(v);
          }
      }
                

      void setVar(ScriptObject f) {
          //IF state is unknown, then set the state to error state,
          //IF state is var state, then set the var object to this.
          //IF state is function state, then go to error state.
          //If state is varFull state, then go to error state.
      }
      ScriptObject getResult() {
          //If state != varFullState, or function state, return errorState
          //Else perform the appropriate set, either set the BuilderFactory, or the map in the current environment
          //And return null script object..
      }
            
            
  }

  class EnvironmentList {
      ArrayList<Environment> environments = new ArrayList<Environment>();
      ScriptObject hasVariable(String name) {
          ListIterator li = environment.listIterator(environment.size());
          while(li.hasPrevious()) {
              Map<String,ScriptObject> vars = li.previous.getVars();
              if ( vars.get(name) != null ) {
                  return vars.get(name);
              }
          }
          return null;
      }

      Builder hasBuilder(String name) {
          ListIterator li = environment.listIterator(environment.size());
          while(li.hasPrevious()) {
              BuilderFactory b = li.previous.getBuilderFactory();
              if ( BuilderFactory.get(name) != null ) {
                  return BuilderFactory.get(name);
              }
          }
          return null;
      }

      void pushEnv(Environment env) {
          environments.add(env);
      }
      void popEnv() {
          environments.remove(environments.size()-1);
      }
      void addToTopEnv(String name, ScriptObject obj);
      void addToTopEnv(String name, Builder obj);
  }

  class Environment {
      BuilderFactory builder;
      Map<String,ScriptObject> vars;
      //Has getters for each.
  }
        

  class ScriptEvaluator {
      //Lots of stuff elidded
      //When looking up a variable, a function will start at the back of list,
      //And go through it, checking each one, and taking the first match. 
      //The first environment must be specially initialized with the BuilderFactory that has the
      //Correct special builders.
      EnvironmentList envList = new EnvironmentList();
      //The thing making the script evaluator must be smart enough to put the global env in.
      //A function, when it is first evaluated, needs to put a new frame into env, and then
      //On exit, pop a frame off of env.

      ArrayList<BuilderFactory>  = ...;

           
      ScriptObject doParse(Tokens token) {
          Builder builder = token.getBuilder(this);
              
          for (Token arg : token.getArgumentTokens()) {
              builder.addToken(this);
          }
          ScriptObject obj = builder.getResult();

          return obj;
      }
  }

  abstract class Token {
      abstract ArrayList<Token> getArguments();
      abstract Builder getBuilder(Assembler assembler);
  }

  class ExpressionToken extends Token {
      //...Lots of stuff elidded
      ArrayList<Token> getArguments(); //Return the sub expression
      //Tokens
      Builder getBuilder(Assembler assembler) {
          return BuilderFactory.getInstance().getBuilder(
              assembler,this.getFunctionString());
      }

  }

  class AtomToken extends Token {
      //This is the token for a literal
      ArrayList<Token> getArguments(); //Always returns
      //Empty list
      Builder getBuilder(Assembler assembler) { 
          return 
              BuilderFactory.getInstance().getLiteralBuilder(
                  assembler,this.value());
      }
  }

  class VariableToken extends Token {
      //This is the token for a variable
      ArrayList<Token> getArguments(); //Always returns
      //Empty list
      Builder getBuilder(Assembler assembler) { 
          return 
              BuilderFactory.getInstance().getVariableBuilder(
                  assembler,this.varName());
      }
  }


  class BuilderFactory {
      //singleton stuff

      //Paramatized factory
      Map<String,BuilderClassObjects> map;
  }
  //We will also most likely want a singleton to log errors!

#+END_SRC

**** UML

Currently, no options object.
Might want to  add in options object later.. Or it might be done at a higher level than this.
#+BEGIN_SRC plantuml :file BuilderConstruction.png
skinparam dpi 300

abstract class BuilderVisiter as "{abstract}\nScriptObjectBuilder"
abstract class ScriptObject as "{abstract}\nScriptObject"


ScriptObject : acceptBuilder(ScriptObjectBuilder v)

BuilderVisiter : -eval : ScriptEvaluator
BuilderVisiter : +getResult():ScriptObject
BuilderVisiter : +addLayout(l:Layout)
BuilderVisiter : +addDecal(d:Decal)
BuilderVisiter : +addString(s:StringScriptWrapper)
BuilderVisiter : +addFamily(f:Family)
BuilderVisiter : +addSize(s:Size)
BuilderVisiter : +addPositionScaled(ps:PositionScaled)
BuilderVisiter : +addCard(c:Card)
BuilderVisiter : +addInt(s:IntScriptWrapper)
BuilderVisiter : +addList(l:List<ScriptObject>)
BuilderVisiter : +addPair(p:Pair<ScriptObject,ScriptObject>)
BuilderVisiter : +addKeyValuePair(p:Pair<StringScriptWrapper,Decal>)
BuilderVisiter : +addLayoutPositionPair(p:Pair<Layout,Position>)
BuilderVisiter : +addError(e:ErrorScriptObject)
BuilderVisiter : +addNull(v:NullScriptObject)
BuilderVisiter : +addToken(t:Token)
BuilderVisiter : -addScriptObject(s:ScriptObject)
note top : addToken will be implemented by default as running eval.doParse on the token, and then having the token accept itself.

note bottom : The add methods by default will forward to addScriptObject, so that each add* doesn't need to be overridden, can only override the adds that are expected, and can otherwise switch to error if an unexpected thing is added. 












abstract class Token as "{abstract}\nToken"


Token : getArguments():List<Token>
note top : For example,\n if (render someCard familyA (family \"foo\" (cons \"foo\" bar)), \n then someCard will be one token, familyA another, (family \"foo\" (cons \"foo\" bar)) will be a third. "
Token : getBuilder(ScriptEvaluator ScriptEvaluator):Builder
class VariableToken
note bottom : FamilyA would be one of these tokens, a variable that is referenced. \n A variable name can't start with a number, to make it determinable from an int.
note left : When asked for a builder, will look in the ScriptEvaluators environment for a variable of it's name. \n If found, return a VariableBuilder, paramatized with said ScriptObject. \n If not found, return an UndefinedVariableBuilder, paramatized with the name.
VariableToken : varName : String
class ExpressionToken
note top : (family "foo" (cons "foo" bar)) would be one of these
note left : When asked for a builder, will look in environment for builder matching current function name. \n If none found, will create an UndefinedFunctionBuilder, with the name, and paramater names paramaterized
ExpressionToken : List<Token>
abstract class AtomToken as "{abstract}\nAtomToken"
note top : Any ints or strings will be one of these. 
class StringAtomToken 
note bottom : When asked for a builder, returns a ConstantBuilderVisiter, paramatized with an StringScriptWrapper of the appropriate value
StringAtomToken : value : String
class IntAtomToken
IntAtomToken : value : int
note bottom : When asked for a builder, returns a ConstantBuilderVisiter, paramatized with an IntScriptWrapper of the appropriate value
class ParseErrorToken
note top : If a parse error is hit, then make this, and stop parsing.
ParseErrorToken : error : String


ParseErrorToken : getBuilder(ScriptEvaluator ScriptEvaluator): ErrorBuilderVisiter
AtomToken : getBuilder(ScriptEvaluator ScriptEvaluator): ConstantBuilderVisiter
VariableToken : getBuilder(ScriptEvaluator ScriptEvaluator): VariableBuilderVisiter

note "These tokens will add the info the builder they are returning needs, before returning" as N1

N1 -- AtomToken
N1 -- VariableToken
N1 -- ParseErrorToken

Token <|-- VariableToken
note bottom : Get arguments is always empty
Token <|--ExpressionToken
Token <|--AtomToken
AtomToken <|--IntAtomToken
AtomToken <|--StringAtomToken
Token <|--ParseErrorToken
note bottom : Get arguments is always empty



note "As defined in other UML, members and operations ellided in this one" as AsDefined
note "If a Pair Builder encounters a string + decal,\n or a Layout + Position,\n it will make the appropriate pair subclass. This is a bit ugly though" as subpairs

abstract class Layout as "{abstract}\nComponentLayout"
Layout -- AsDefined
abstract class Decal as "{abstract}\nDecal"
Decal -- AsDefined
class consPair
class KeyValuePair
class LayoutPositionPair
class List
class ErrorScriptObject
class NullScriptObject
class Card 
Card -- AsDefined
class PositionScaled
PositionScaled -- AsDefined
class Size
Size -- AsDefined
class IntScriptWrapper
IntScriptWrapper : value : int
class StringScriptWrapper
StringScriptWrapper : value : String
class Family
Family -- AsDefined

class UndefinedFunction
UndefinedFunction : -funcName : String
UndefinedFunction : -funcArgumentNames : ArrayList<String>
UndefinedFunction : +getFuncName() : String
UndefinedFunction : +getFuncArgumentNames() : ArrayList<String>

class UndefinedVariable
UndefinedVariable : variableName : String
UndefinedVariable : getVariableName() : String


ScriptObject <|-- Family
ScriptObject <|-- StringScriptWrapper
ScriptObject <|-- IntScriptWrapper
ScriptObject <|-- Size
ScriptObject <|-- PositionScaled
ScriptObject <|-- Card
ScriptObject <|-- ErrorScriptObject
ScriptObject <|-- NullScriptObject
ScriptObject <|-- List
ScriptObject <|-- consPair
consPair <|-- KeyValuePair
consPair <|-- LayoutPositionPair
subpairs -- consPair
ScriptObject <|-- Decal
ScriptObject <|-- Layout

ScriptObject <|-- UndefinedFunction
ScriptObject <|-- UndefinedVariable

class BuilderFactory


BuilderFactory : Map<String,ScriptObjectBuilder>
BuilderFactory : getBuilder(s:String)
BuilderFactory : getBuilderFactory() : BuilderFactory

class Environment
Environment : builders : BuilderFactory 
Environment : variables : Map<String,ScriptObject>
Environment : getVariables() : Map<String,ScriptObject>
Environment : getBuilders() : BuilderFactory

class EnvironmentList

EnvironmentList : envs : ArrayList<Environment>
EnvironmentList : hasVariable(String name) : ScriptObject
EnvironmentList : hasBuilder(String name) : BuilderFactory
EnvironmentList : pushEnv(Environment env) : void
EnvironmentList : popEnv() : void
EnvironmentList : addToTopEnv(name:String,obj:ScriptObject):void
EnvironmentList : addToTopEnv(name:String,builder:ScriptObjectBuilder):void


note top : The EnvironmentList starts checking from the most recently pushed, until it gets to the oldest env. If no matching variable/builder is found, returns null.

EnvironmentList o-> Environment

class ScriptEvaluator

ScriptEvaluator : currentDirectory:Path
ScriptEvaluator : parseFile(Path) : List<Token>
ScriptEvaluator : evalTokans(List<Token>) : void
ScriptEvaluator : doParse(Token) : ScriptObject
ScriptEvaluator : getCardsThatWereRendered() : List<RenderedCards>
ScriptEvaluator : addRenderedCard(RenderedCard rc)
ScriptEvaluator : getEnvironmentList() : EnvironmentList

ScriptEvaluator -> EnvironmentList

note top : doParse gets the builder for that token, from the token, then for each argument token in the token, gives the builder said token, before returning the builder result. 



Token -> BuilderFactory


class RenderedCard

RenderedCard : -Card:card
RenderedCard : -Families:ArrayList<Family>
RenderedCard : -name:String
RenderedCard : +getCard():card
RenderedCard : +getFamilies():ArrayList<Family>
RenderedCard : +getName():String






note  "Getting stuff out of cons for layout and family will be a bit tricky, but doable, \n doing that is one weakness of this design, but can still do it without casting." as weakness

note "See each Builders UML for more details..., members and operations ellided in this one" as BuilderNoteS
'The builders

' VarBuilder
note "The Varbuilder is made by var token, so var token paramatizes VarBuilder with what it gets from looking up the var." as simpleBuilderNote
class VarBuilder as "VariableBuilderVisiter"
note top : Just returns the ScriptObject it is paramatized with as a result. Attemping to add to it will make it enter error state. 
simpleBuilderNote -- VarBuilder
BuilderVisiter <|-- VarBuilder

'ConstantVisiter
class ConstantBuilder as "ConstantBuilderVisiter"
note top : Before the token returns it,\n the token will add the constant using the correct add method. 
BuilderVisiter <|-- ConstantBuilder

'LayoutVisiter
class LayoutBuilder as "LayoutBuilderVisiter"

BuilderVisiter <|-- LayoutBuilder


note bottom : Get result returns either a layout of some form, or an ErrorScriptObject, \n depending on arguments being given in.

'Define builder
class DefineBuilder 
BuilderVisiter <|-- DefineBuilder 
BuilderNoteS -- DefineBuilder 

'CardBuilder 
class CardBuilder 
BuilderVisiter <|-- CardBuilder 
BuilderNoteS -- CardBuilder 

'NullBuilder 
class NullBuilder 
BuilderVisiter <|-- NullBuilder 
BuilderNoteS -- NullBuilder 

'UndefinedFunctionBuilder 
class UndefinedFunctionBuilder 
BuilderVisiter <|-- UndefinedFunctionBuilder 
BuilderNoteS -- UndefinedFunctionBuilder 

'UndefinedVariableBuilder 
class UndefinedVariableBuilder 
BuilderVisiter <|-- UndefinedVariableBuilder 
BuilderNoteS -- UndefinedVariableBuilder 

'ListBuilder 
class ListBuilder 
BuilderVisiter <|-- ListBuilder 
BuilderNoteS -- ListBuilder 

'ConsBuilder 
class ConsBuilder 
BuilderVisiter <|-- ConsBuilder 
BuilderNoteS -- ConsBuilder 

'SizeBuilder 
class SizeBuilder 
BuilderVisiter <|-- SizeBuilder 
BuilderNoteS -- SizeBuilder 

'PositionScaledBuilder 
class PositionScaledBuilder 
BuilderVisiter <|-- PositionScaledBuilder 
BuilderNoteS -- PositionScaledBuilder 

'FamilyBuilder 
class FamilyBuilder 
BuilderVisiter <|-- FamilyBuilder 
BuilderNoteS -- FamilyBuilder 

'ImageDecalBuilder 
class ImageDecalBuilder 
BuilderVisiter <|-- ImageDecalBuilder 
BuilderNoteS -- ImageDecalBuilder 

'StringDecalBuilder 
class StringDecalBuilder 
BuilderVisiter <|-- StringDecalBuilder 
BuilderNoteS -- StringDecalBuilder 

'ShapeDecalBuilder 
abstract class ShapeDecalBuilder as "{abstract}\nShapeDecalBuilder"
BuilderVisiter <|-- ShapeDecalBuilder 
BuilderNoteS -- ShapeDecalBuilder 

'RectangleDecalBuilder
class RectangleDecalBuilder
BuilderVisiter <|-- RectangleDecalBuilder
BuilderNoteS -- RectangleDecalBuilder

'CircleDecalBuilder 
class CircleDecalBuilder 
BuilderVisiter <|-- CircleDecalBuilder 
BuilderNoteS -- CircleDecalBuilder 

'TriangleDecalBuilder
class TriangleDecalBuilder
BuilderVisiter <|-- TriangleDecalBuilder
BuilderNoteS -- TriangleDecalBuilder

'AnyShapeDecalBuilder
class AnyShapeDecalBuilder
BuilderVisiter <|-- AnyShapeDecalBuilder
BuilderNoteS -- AnyShapeDecalBuilder

'FunctionBuilder
class FunctionBuilder
BuilderVisiter <|-- FunctionBuilder
BuilderNoteS -- FunctionBuilder
#+END_SRC

#+RESULTS:
[[file:BuilderConstruction.png]]


**** Builders we need
- LayoutBuilder : Ervis
- DefineBuilder : Matt
  #+BEGIN_SRC plantuml :file DefineBuilder.png
    skinparam dpi 300

    note "This must be set in the global environment as an already existing builder" as note1

    class DefineBuilder

abstract class ScriptObjectBuilder as "{abstract}\nScriptObjectBuilder"

ScriptObjectBuilder <|-- DefineBuilder

    DefineBuilder : functionBuilder : FunctionBuilder = null
    DefineBuilder : state : State = new UnknownState()
    DefineBuilder : var : ScriptObject = new NullScriptObject();
    DefineBuilder : name : String
    DefineBuilder : addToken(token:Token) : void
    DefineBuilder : addUndefinedVariable(v:UndefinedVariable) : void
    DefineBuilder : addUndefinedFunction(f:UndefinedFunction) : void
    DefineBuilder : getResult() : ScriptObject
    DefineBuilder : addScriptObject(s:ScriptObject) : void
    DefineBuilder : setVariable(v:ScriptObject)
    DefineBuilder : setName(name:String )
    DefineBuilder : setState(state:State)
    DefineBuilder : setFunctionBuilder(functionBuilder:FunctionBuilder)
    DefineBuilder : getFunctionBuilder():FunctionBuilder

    note bottom : Forwards calls to addToken, addUndefinedFunction,addUndefinedVariable, and addScriptObject to state. 

    abstract class State as "{abstract}\nState"
    State : addToken(t:Token,ScriptEvaluator,this:DefineBuilder)
    State : addUndefinedFunction(f:UndefinedFunction,env:ScriptEvaluator,this:DefineBuilder)
    State : addUndefinedVariable(v:UndefinedVarialbe,env:ScriptEvaluator,this:DefineBuilder)
    State : addScriptObject(o:ScriptObject,env:ScriptEvaluator,this:DefineBuilder)

    class UnknownState
    UnknownState : addToken(t:Token,ScriptEvaluator,this:DefineBuilder)
    UnknownState : addUndefinedFunction(f:UndefinedFunction,env:ScriptEvaluator,this:DefineBuilder)
    UnknownState : addUndefinedVariable(v:UndefinedVarialbe,env:ScriptEvaluator,this:DefineBuilder)
    UnknownState : addScriptObject(o:ScriptObject,env:ScriptEvaluator,this:DefineBuilder)
    
    note top of UnknownState
         addToken : Has the eval parse the token, and then has the object accept the DefineBuilder
         addUndefinedFunction : Sets the state to FunctionState, and make a FunctionBuilder object
                              The Function builder object gets the UndefinedFunctions paramater name list, and name is set to the undefined functions name.
         addUndefinedVarialbe : Sets the state to EmptyVariable state, and sets the name to the variable name.
         getResult() : Return error Script Object
    end note

    class EmptyVariableState
    EmptyVariableState : addToken(t:Token,ScriptEvaluator,this:DefineBuilder)
    EmptyVariableState : addUndefinedFunction(f:UndefinedFunction,env:ScriptEvaluator,this:DefineBuilder)
    EmptyVariableState : addUndefinedVariable(v:UndefinedVarialbe,env:ScriptEvaluator,this:DefineBuilder)
    EmptyVariableState : addScriptObject(o:ScriptObject,env:ScriptEvaluator,this:DefineBuilder)

    note top of EmptyVariableState
         addToken : Has the eval parse the token, and then has the object accept the DefineBuilder
         addUndefinedFunction : Set the variable to given undefined function ScriptObject
         addUndefinedVarialbe : Set the variable to given undefined variable ScriptObject
         getResult() : Return error Script Object
    end note

    class FullVariableState
    FullVariableState : addToken(t:Token,ScriptEvaluator,this:DefineBuilder)
    FullVariableState : addUndefinedFunction(f:UndefinedFunction,env:ScriptEvaluator,this:DefineBuilder)
    FullVariableState : addUndefinedVariable(v:UndefinedVarialbe,env:ScriptEvaluator,this:DefineBuilder)
    FullVariableState : addScriptObject(o:ScriptObject,env:ScriptEvaluator,this:DefineBuilder)

    note top of FullVariableState
         addToken : Has the eval parse the token, and then has the object accept the DefineBuilder
         addUndefinedFunction : Go to error state
         addUndefinedVarialbe : Go to error state
         getResult() : Get the environment from evaluator, and add the name -> variable key value pair
                     to the variable map to current env, then return a NullScriptObject
    end note

    class FunctionState
    FunctionState : addToken(t:Token,ScriptEvaluator,this:DefineBuilder)
    FunctionState : addUndefinedFunction(f:UndefinedFunction,env:ScriptEvaluator,this:DefineBuilder)
    FunctionState : addUndefinedVariable(v:UndefinedVarialbe,env:ScriptEvaluator,this:DefineBuilder)
    FunctionState : addScriptObject(o:ScriptObject,env:ScriptEvaluator,this:DefineBuilder)

    note top of FunctionState
         addToken : Add unparsed token to function builder, this is the function body.
         addUndefinedFunction : Go to error state
         addUndefinedVarialbe : Go to error state
         getResult() : Get the environment from evaluator, and add the name -> Builder key value pair
                     to the BuilderFactory to current env, then return a NullScriptObject
    end note

    class ErrorState
    ErrorState : addToken(t:Token,ScriptEvaluator,this:DefineBuilder)
    ErrorState : addUndefinedFunction(f:UndefinedFunction,env:ScriptEvaluator,this:DefineBuilder)
    ErrorState : addUndefinedVariable(v:UndefinedVarialbe,env:ScriptEvaluator,this:DefineBuilder)
    ErrorState : addScriptObject(o:ScriptObject,env:ScriptEvaluator,this:DefineBuilder)
    ErrorState : errorMessage : String

    note top of ErrorState
         
         addToken : Has the eval parse the token, and then has the object accept the DefineBuilder
         addUndefinedFunction : Update error message
         addUndefinedVarialbe : Update error message
         getResult() : Return new ErrorScriptObject paramatarized with the error message. 
                     
    end note

DefineBuilder +-- State
State <|-- UnknownState
State <|-- EmptyVariableState
State <|-- FullVariableState
State <|-- FunctionState
State <|-- ErrorState
      
  #+END_SRC

  #+RESULTS:
  [[file:DefineBuilder.png]]
- FunctionBuilder : Matt
  #+BEGIN_SRC plantuml :file FunctionBuilder.png
skinparam dpi 300
class FunctionBuilder

abstract class ScriptObjectBuilder as "{abstract}\nScriptObjectBuilder"

ScriptObjectBuilder <|-- FunctionBuilder
FunctionBuilder : -paramNames : ArrayList<String>
FunctionBuilder : -paramObjects : ArrayList<ScriptObject>
FunctionBuilder : -addScriptObject(s:ScriptObject) : Add s to paramObjects list
FunctionBuilder : +setParamNames(names:ArrayList<String>) : Add s to paramObjects list
FunctionBuilder : +getResult() : ScriptObject 
FunctionBuilder : -functionBody : ArrayList<Token>
FunctionBuilder : +addFunctionBodyToken(t:Token)

note bottom : FunctionBuilder is retrieved from the environments BuilderFactory.
note bottom : getResult() will compare paramNames and paramObjects lengths. \n If they are different lengths, return an error. \n Otherwise, make a new Environment. Add to it all the given variables. \n Then, push that environment into the evals environment list. Then call doParse(token) for each token in the functionBody list. \n Then pop an env frame from the EnvironmentList, and return the last obj returned from doParse.

  #+END_SRC

  #+RESULTS:
  [[file:FunctionBuilder.png]]

- CardBuilder :  Ian
- NullBuilder : Ian
- UndefinedFunctionBuilder : Matt
- UndefinedVariableBuilder : Matt
- ListBuilder : Ian 
- ConsBuilder : Brandon
- SizeBuilder : Brandon
- PositionScaledBuilder : Brandon
- FamilyBuilder : Matt
- VariableBuilder : Matt
  #+BEGIN_SRC plantuml :file Variablebuilder.png
skinparam dpi 300
class VariableBuilderVisiter

abstract class ScriptObjectBuilder as "{abstract}\nScriptObjectBuilder"

ScriptObjectBuilder <|-- VariableBuilderVisiter

VariableBuilderVisiter : -addScriptObject(s:ScriptObject) : Go to error state
VariableBuilderVisiter : +getResult() : ScriptObject 
VariableBuilderVisiter : -obj:ScriptObject
VariableBuilderVisiter : -state:State = new NormalState
VariableBuilderVisiter : +VariableBuilder(ScriptObject)

note bottom : The variable visiter is unlike most other visiters,\n it's made by the Variable token directly, and get result simply returns the obj it is paramaterized with. Adding anything to it sets it to error state, \n which will make it return an error obj instead...
note bottom : addScriptObject(s:ScriptObject) will just do state = state.addScriptObj() \n and getResult will return state.getResult(obj)

abstract class State as "{abstract}\nState"
State : getResult(s:ScriptObject) : ScriptObject
State : addScriptObj() : State

VariableBuilderVisiter +-- State

class ErrorState 
ErrorState : getResults(s:ScriptObject) : ScriptObject
ErrorState : addScriptObj() : State 

note top : addScriptObj() always returns this \n getResults() always returns a new ErrorScriptObject

class NormalState 
NormalState : getResults(s:ScriptObject) : ScriptObject
NormalState : addScriptObj() : State 

State <|-- ErrorState
State <|-- NormalState

note top : addScriptObj() always returns new ErrorState() \n getResults() always returns an obj

  #+END_SRC

  #+RESULTS:
  [[file:Variablebuilder.png]]

- ConstantBuilder : Matt
  #+BEGIN_SRC plantuml :file ConstantBuilder.png
skinparam dpi 300
class ConstantBuilderVisiter

abstract class ScriptObjectBuilder as "{abstract}\nScriptObjectBuilder"

ScriptObjectBuilder <|-- ConstantBuilderVisiter

ConstantBuilderVisiter : -addScriptObject(s:ScriptObject) : Go to error state
ConstantBuilderVisiter : +getResult() : ScriptObject 
ConstantBuilderVisiter : -obj:ScriptObject
ConstantBuilderVisiter : -state:State = new NormalState
ConstantBuilderVisiter : +ConstantBuilder(ScriptObject)

note bottom : The Constant visiter is unlike most other visiters,\n it's made by the Constant token directly, and get result simply returns the obj it is paramaterized with. Adding anything to it sets it to error state, \n which will make it return an error obj instead...
note bottom : addScriptObject(s:ScriptObject) will just do state = state.addScriptObj() \n and getResult will return state.getResult(obj)

abstract class State as "{abstract}\nState"
State : getResult(s:ScriptObject) : ScriptObject
State : addScriptObj() : State

ConstantBuilderVisiter +-- State

class ErrorState 
ErrorState : getResults(s:ScriptObject) : ScriptObject
ErrorState : addScriptObj() : State 

note top : addScriptObj() always returns new ErrorState() \n getResults() always returns a new ErrorScriptObject

class NormalState 
NormalState : getResults(s:ScriptObject) : ScriptObject
NormalState : addScriptObj() : State 

State <|-- ErrorState
State <|-- NormalState

note top : addScriptObj() always returns new ErrorState() \n getResults() always returns an obj

  #+END_SRC

  #+RESULTS:
  [[file:ConstantBuilder.png]]

- DecalBuilders 
  - ImageDecalBuilder :  Brandon
  - StringDecalBuilder : Brandon 
  - ShapeDecalBuilders : Ervis
    - RectangleDecalBuilder : Ervis
    - CircleDecalBuilder : Ervis
    - TriangleDecalBuilder : Ervis
    - AnyShapeDecalBuilder : Ervis
** ScriptEvaluator
- After parsing script, can return a list of tuples, each tuple has front image, back image, card name. 
- Uses a strategy for parsing. 
- Will likely want an overall parser, and a per sexp parser that can be recursively called on argument.
  


*** Assembling strategy
- We want to handle various languages, but don't want to rewrite the code that assembles the objects together.
- Strategy will be the assembler
  - Context will be the parser
- Context will continue to parse
- Context will then call strategy with each function + arguments.
  - These functions + arguments should be agnostic of the language.
  - Local arguments, like (card (size 100 100) "foo" (leaf-layout white-rectangle) (leaf-layout white-rectangle)), each argument will be held locally, will call to strategy to initiate each 
  - arg, strategy will return that, then call strategy with cards + now initialized args. 
  - If defining, after calling strategy with to get the object, proceed to tell the strategy to store it. 

*** Assembling with builder!
- Allows one to create objects from the scripting langauge cleanly.
  - Context sees it is making something new, sees what it is making from function.
  - Token comparison will have to happen some how, although could avoid a hard coded comparison...
  - A FooBuilder is made. 
  - For each argument in foo, if it's a simple variable, grab it, if a new object as well, recursively run this to make it, and then....
  - We store things as a broad supertype for all available types.
  - This type then takes in the FooBuilder, and call the addAsArgMyType(this)
    #+BEGIN_SRC java
//Bar was made from the arguments
class BarType {
//...Ellided stuff

void acceptBuilder(Builder builder) {
   buildee.addAsArgMyType(this);
}
    
    #+END_SRC
  - When all arguments are in the builder, do builder.getScriptObject(), returning a script object. 
  - If the builder was given arguments that it couldn't work with, then it will return null.
  
  - Why go through all this hassle?
  - Then we can store all objects the script makes in a map of strings -> scriptobject.
  - And then, when we reference them to create another object, we can do it without casting!
  - It's essentially combing builder + visiter.
  - This is instead of an abstract factory!
    - Because an abstract Factory doesn't actually make that much sense!
    - We aren't switching between families of types!
    - Factory method could work better than that I think?. 
      
  - Builders can use state pattern!
    - Start at GenericLayout for example
    - Go to error state if someone tries passing a card in, or something
    - Go to leaf state if decal passed in, etc.
      
*** Both the above strategies work, and keep actually assembling the object separate from parsing.
- A different parser could probably use the same builders.
  - The director is the parser!
  - Sorta strange to swap out directors, rather than builders, but eh....
- Builder idea is my favorite


** InternalStructureManagement
- Abstract LayoutFactory
  - Gets input a layout, and the arguments to create layout.
  - Returns a layout for that. 
- DecalFactory
- Do the factories actually make sense?
- Only one family?
- Builder instead?



