#+AUTHOR: Matthew Bregg, Brandon Duong, Ian Fell, Ervis Shqiponja
#+LATEX_HEADER: \usepackage[margin=1.0in]{geometry}
* Overall System, How all these sub systems interact
The driver system gets everything going, and runs things at the highest level perspective.
It's what reads in the initial options, sets the ScriptEvaluator, and makes the ScriptEvaluator.

The driver then will let options get the correct file, and then get the Lexer from the ScriptEvaluator, tokenize the file, eval the tokens.
Then, it will take the RenderedCard list, give each card to output, with options.
Output will then write the card to disk.
The program is then done, exit, printing any information left in logger. 

Note that during each step, the Driver checks logger for errors, and decides if it should abort. 

This describes the highest level of how the systems interact.
For detail of how the systems interact internally, see each system.

* Plugins
Custom builders can be written, and then loaded in at runtime.
See the config section of the Script Specification for details. 
* Turing Complete
To quote Wikipedia, 
#+BEGIN_QUOTE
Turing complete if it has conditional branching (e.g., "if" and "goto" statements, or a "branch if zero" instruction. See OISC) and the ability to change an arbitrary amount of memory locations (e.g., the ability to maintain an arbitrary number of variables).
#+END_QUOTE
#+BEGIN_SRC 
Wikipedia contributors. "Turing completeness." Wikipedia, The Free 
   Encyclopedia. Wikipedia, The Free Encyclopedia, 15 Oct. 2015. Web. 5 Dec. 2015.

#+END_SRC
- Our language has
  - If statements
  - Ability to define variables
 
* General Goals, and Overview
** What features the system has
The goal of our project is to design a functional Script-driven card generator (SDCG) system that can output highly customizable cards. Using a lisp-esque inspired script language, the user can easily construct a multitude of unique card decks. The cards will be built from scratch using graphics, images, and text imputed in from the user. The images imputed are easily scalable and can be stretched or specified to maintain its original width, height, or even its aspect ratio. Our design allows for not only an easily customizable front layout, but also one for the back as well. Since most decks will have common patterns found throughout all the cards, we encourage users to make use of the layout component, which will enable the user to reuse and recycle similar base designs when making their cards. Another unique functionality of our design is the family component. With the use of families a user will be able to map user-made strings with specific images.  This is useful when decks are divided into subdecks containing common images in each subdeck, because the added functionality this aspect gives is for cards with similar layouts containing different images. When a user renders a card, it asks for the family as well, and will render all the images that are mapped with any of the keys it finds. This will render the appropriate image based on the key the user built the card or layout with. Lastly, our script language allows the construction of functions to help aid in process of creating your deck. Functions allow the user to create layouts with generic variable arguments that can be passed in when creating or rendering objects.

** Scripting Language Specifications
#+INCLUDE: "./ScriptingLanguageSpecification.org"

** Examples
*** 52 cards
- Config
#+INCLUDE: "./Examples/52_deck_example/52CardDeck.config" src scheme
- Script
#+INCLUDE: "./Examples/52_deck_example/52CardDeck.script" src scheme

**** Data files
\newline

#+ATTR_LATEX: :width 3cm
file:Examples/52_deck_example/cardBack.png

#+ATTR_LATEX: :width 3cm
file:Examples/52_deck_example/clubs.png
#+ATTR_LATEX: :width 3cm
file:Examples/52_deck_example/diamond.png
#+ATTR_LATEX: :width 3cm
file:Examples/52_deck_example/hearts.png
#+ATTR_LATEX: :width 3cm
file:Examples/52_deck_example/spades.png
#+ATTR_LATEX: :width 3cm
file:Examples/52_deck_example/jackClubs.png
#+ATTR_LATEX: :width 3cm
file:Examples/52_deck_example/jackDiamond.png
#+ATTR_LATEX: :width 3cm
file:Examples/52_deck_example/jackHearts.png
#+ATTR_LATEX: :width 3cm
file:Examples/52_deck_example/jackSpades.png
#+ATTR_LATEX: :width 3cm
file:Examples/52_deck_example/kingClubs.png
#+ATTR_LATEX: :width 3cm
file:Examples/52_deck_example/kingDiamond.png
#+ATTR_LATEX: :width 3cm
file:Examples/52_deck_example/kingHearts.png
#+ATTR_LATEX: :width 3cm
file:Examples/52_deck_example/kingSpades.png
#+ATTR_LATEX: :width 3cm
file:Examples/52_deck_example/queenClubs.png
#+ATTR_LATEX: :width 3cm
file:Examples/52_deck_example/queenDiamond.png
#+ATTR_LATEX: :width 3cm
file:Examples/52_deck_example/queenHearts.png
#+ATTR_LATEX: :width 3cm
file:Examples/52_deck_example/queenSpades.png

**** Mock-Ups
\newline
file:Examples/52_deck_example/52CardDeck.jpg

*** Monopoly
- Config
#+INCLUDE: "Examples/monopoly_example/monopoly.script" src scheme
- Script
#+INCLUDE: "Examples/monopoly_example/monopoly.config" src scheme

**** Data files

#+ATTR_LATEX: :width 3cm
file:Examples/monopoly_example/images/electric_company.png
#+ATTR_LATEX: :width 3cm
file:Examples/monopoly_example/images/railroad.png
#+ATTR_LATEX: :width 3cm
file:Examples/monopoly_example/images/water_works.png

**** Mock-Ups (Mockups made, created and generated by Nandeck)

file:Examples/monopoly_example/monopoly.pdf

* Card Representation System
** Overview
The Card object is constructed by five attributes: two layouts for front and back, a name, a width and a height, and a shape.
The layout is of object ComponentLayout, which could be composed of either a list of  LayoutTuples or a Decal.
A LayoutTuple is a POD with a Layout, PositionScaled, and a Shape.
A Decal is the base object that can be put on a Card object.
A Decal can be made of either an Image, a Text, a DynamicDecal or a color object.

** ScriptObject Class
- *Purpose:* 
It is an abstract class which will be declaring the interface for all the concrete object to use. The subclasses will be overriding its method, ~acceptBuilder ()~, in order to create a builder to build objects.
- *Interaction:*  
This class does not inherit from any other classes, however it serve as a base class for all other components, which will be inheriting from this.
- *Design Patterns it belongs:*
This class is only part of the visiter pattern explicitly, but lots of design patterns will be used in its subclasses and by overriding its method.


** ComponentLayout Class
- *Purpose:* 
It is an abstract class which declares an interface for the objects that can belong to a layout such as a Decal or another layout. It will implement the default behaviours for some of the functionalities which will be the same in all the class that will inherit from this. It will declare an interface for accessing the child components.
- *Interaction:*  
This abstract class will be inheriting from ScriptObject class which is another abstract class. In addition it will override the method necessary to build the layouts called ~acceptBuilder ()~. Two subclasses will inherit from this, the LeafLayout class and CompositeLayout class.
- *Design Patterns it belongs:*
This class is designed using Composite design pattern and the iterator design patterns is included in it as well. 

*** LeafLayout Class
- *Purpose:* 
It is an abstract class that will represent the leaf object in a composition. It has no children and the leaf will be of type object Decal. Moreover, this class has character attribute to denote the size that the decal will have in relative to the layout. The options are specified in the *ScriptingLanguageSpecification.org*. It will call render on the decal held, and pass in the appropriate information. 
- *Interaction:*  
This class will inherit from the ComponentLayout abstract class. In addition from this class we can navigate to the abstract class Decal.
- *Design Patterns it belongs:*
This class is designed using Composite design pattern.

*** CompositeLayout Class
- *Purpose:* 
It is an abstract class that will declare an interface for components that will have children. In addition it will provide default implementation to some of the methods necessary for adding child layout components and for rendering layouts into the card or another layout. It will also provide a default implementation for the method ~iterator ()~, which will create an iterator to traverse all the composed layouts.
A child of it is a LayoutTuple.
- *Interaction:*   
This class will inherit from the ComponentLayout abstract class and it will serve as a base for the other two classes ArrayComponentLayout and SingleComponentLayout.
- *Design Patterns it belongs:*
This class is designed using Composite design pattern and the Iterator design patterns is included in it as well to offer a way to access the composed layouts.

**** ArrayComponentLayout Class
- *Purpose:* 
This is a concrete class that will be able to hold an array of children of types LayoutTuple. The array will be filled with zero or many references to the LayoutTuple objects.
- *Interaction:*  
This class will inherit form the CompositeLayout abstract class. It will inherit the default implementation for the ~render ()~ method, ~addLayout ()~, ~removeLayout ()~ and ~iterator ()~ to create an iterator.
- *Design Patterns it belongs:*
This class is designed using Composite design pattern and the Iterator design patterns is included in it as well to offer a way to access the composed layouts.

*** LayoutTuple Class
- *Purpose:* 
It is a concrete class which will allow our system to create structure where a specific ComponentLayout is associated with a PositionScaled. This is necessary because every layout must be placed in a specific relatively scaled position.
- *Interaction:*  
This class does not inherit from any other classes, however,  Composite layouts maintain zero or more references to the objects created by this class.
- *Design Patterns it belongs:*
It is not part of any of the design patterns.
- *Contains*
It is a POD, holding a Layout, a PositionScaled, and a Shape.

** Decal Class
Decal provides an interface for something graphical. 
Separate graphical objects from the rest of the system,
  - Inherits from ScriptObject, and thus, can accept a visitor.
  - Implements this Visiter method, visiter only ever need to know if something is a decal, not what type, to the Decal Type is the only Decal that implements acceptBuilder.

*** DecalWithFM
- *Purpose:* 
This abstract class will provide a common interface for various types of decals. I will also be implementing a default behaviors for the ~render ()~ method and ~acceptBuilder ()~ method, the former of which may be overridden, the latter of which is final. 
- *Interaction:*  
This class will inherit from the Decal class and other subclasses will be implementing the rest of the functionalities defined by this abstract class.
- *Design Patterns it belongs:*
  - Has a factory method, to retrieve the correct visitor for rendering the held shape.
- *Rendering* 
  - To render, a decal makes a visitor, has that visitor visit the shape passed in to render, renders that shape with the image/color/text.
  - This process is the same for 3 decals, so they just have to override the FM method, render can be left alone


**** Text Class
- *Purpose:* 
A concrete class which conforms to the interface set by the Decal class. It will user an option to put text objects into a card. It has three attributes a Color, a size and a font. This class will know how to render itself and how to load a text from a path given in the configuration file.
- *Interaction:*  
It will inherit from the abstract class Decal.
- *Design Patterns it belongs:*
No design patters used in it.

**** ImageDecal
- *Purpose:* 
A concrete class which offers the users an option to put an image into a card. This class will know how to render itself and how to load an image from a path given in the configuration file.
- *Interaction:*  
It will inherit from the abstract class Decal.
- *Design Patterns it belongs:*
No design patterns used in it.
Implements the FM.

**** Color Class
- *Purpose:* 
This abstract class will provide a common interface for various colors which conforming to the interface set by the Decal abstract class.
- *Interaction:* 
It will be inheriting from the Decal abstract class 
- *Design Patterns it belongs:*
Implements the FM.

**** Decal Rendering Visiters
Each Visiter knows how to render either a text, image, or color decal for each shape. 
The visiter is made by said decal via an FM, and then is accepted by the shape to do the rendering. 
Paramatized with anything the visitor needs for rendering.

*** DynamicDecal
- *Purpose:* 
It is a concrete class which offers the ability to look up a certain decal by name. It has one attribute of type string which will hold the value of the key.
- *Interaction:*  
It will conform to the interface set by the Decal class and override some of the methods defined in there.
Render will look up the decal in family, and if it exists, then delegate the render call to it. 
- *Design Patterns it belongs:*
It can be seen as the RealSubject in the Proxy design pattern.



** Decal Decorator

The Decal decorators implement the decorator pattern for decals. 
They provide various functionality, such as rounding corners, masks, rotation, or cropping.
Override render to call render on each decal(s), and then do some transformaton to the returned image(s).

*** Pattern
Decorator
*** Purpose
Provide basic manipulation utilities, things such as masks, and rotation, and cropping can be added, and chained, and the thing using it has no idea it is dealing with a decorator, not a true decal. 




** Shapes

*** Shape
Provides a basic interface for a shape that can be visited. 
Subclasses will override with the accept method as appropriate, and will contain attributes to represent their shape. 
*** SubClasses
**** Rectangle Class
- Width
- Height
**** Circle Class
- Radius
**** Triangle Class
- Sides length a,b,c
**** AnyShape Class
- List<Point>
  
*** ShapeVisiter
Interface for something capable of visiting a Shape.
Can be implemented for various things like rendering shapes, positioning things inside shapes...
**** Rendering shape visitor :
Can visit a shape, and then returns a rendered image of it. A version for image, text, and color
**** Abstract Placer :
Can position sub images inside an image, relative to a shape. Used by the CompositeLayout to position it's children inside it's shape. 

** Card Class
- *Purpose:* 
This is a concrete class which will be implementing the interface create by ScriptObject class. The objects create by this class will have all the necessary components that a card needs. In addition it will implement the ~render ()~ method in order to render itself, passing it's size, the families it's receives, and it's shape to each layout. 
- *Interaction:*  
It will be inheriting from the ScriptObject concrete class and it will hold two layouts of type ComponentLayout, size attributes, a name, and a shape. 
- *Design Patterns it belongs:*
No design patterns used in it.

** PositionScaled Class
- *Purpose:*
It is a concrete class which will be implementing the interface defined by the ScriptObject class. It will offer the user to scale position where a component will be placed. The user needs will need to specify the change in percentage for the width, height, x and y position.
- *Interaction:*  
It will implement the interface set from the ScriptObject class and override some of behaviours defined there.
- *Design Patterns it belongs:*
No design patterns used in it.

** Size Class
- *Purpose:*
It is a concrete class used by the user to set the size for various components that will be used in the card. It has two attributes a width and a height.
- *Interaction:*  
It will conform to the interface set by the ScriptObject class.
- *Design Patterns it belongs:*
No design patterns used in it.

** Family Class
- *Purpose:*
It is a concrete class that will offer users the option to associate a certain Decal object with a string. This could be useful because if a certain decal needs to appear in many cards (or layouts) we can refer to it by the name and we don’t need to create it multiple times. 
In this case, the families name will be added to the card name to prevent filename conflicts.
- *Interaction:*  
This class will be implementing the interface set by the ScriptObject class. 
- *Design Patterns it belongs:*
No design patterns used in it.

** ConsPair Class
- *Purpose:*
It is an abstract class that will enable the user to associate two different object with each other. Bothe these object will be of type ScriptObject. Script object is an abstract class implemented by many other concrete classes.
- *Interaction:*  
It will be implementing the interface set by the ScriptObject class and override the functionalities defined in there.
- *Design Patterns it belongs:*
No design patterns used in it.

** List Class 
- *Purpose:*
It is a concrete class that will enable the user to create a list of different objects. The elements in this list will be of type ScriptObject.
- *Interaction:*  
It will conform to the interface set by the ScriptObject class and override some of the functionalities defined there.
- *Design Patterns it belongs:*
No design patterns used in it.

** ErrorScriptObject Class
- *Purpose:*
It is a concrete class whose purpose is to create an error or display an error message if a certain token is undefined or unfound in the script language.
- *Interaction:*  
It will implement and conform to the interface set by the parent class ScriptObject.
- *Design Patterns it belongs:*
No design patterns used in it.

** NullScriptObject Class
- *Purpose:*
It is a concrete class whose purpose is to to denot that there is nothing to be created or nothing is being returned.
- *Interaction:*  
It will implement and conform to the interface set by the parent class ScriptObject.
- *Design Patterns it belongs:*
No design patterns used in it.

** UndefinedFunction Class
- *Purpose:*
It is a concrete class whose purpose is to throw an error when a call to an undefined function is made. The functions should be defined in the scripting language and then later on called with respective parameters.
When a define builder receives it as a first argument, it will then define it!
- *Interaction:*  
It will implement and conform to the interface set by the ScriptObject class.
- *Design Patterns it belongs:*
No design patterns used in it.

** RenderedCard Class
- *Purpose:*
It is a concrete class, whose object will be created as the final result of calling render methods in every component. When everything is rendered, this object will be created.
- *Interaction:*  
It will not be inheriting form any other class or being used as subclass for other classes. However, it will be create by the ScrinptEvaluater’s concrete classes.
- *Design Patterns it belongs:*
No design patterns used in it.

** Design Patterns used in Card Representation System
The design pattern that we thought would be fit to use in the Card Representation System are *Composite*, *Iterator*, *Proxy*, *Addapter*, *Factory Method*,  *Visiter* and *Decorator*.
*** Factory Method
**** Why we used?
Each non decorating, and non dynamic decal has a specific visiter which it must make. The super is the client. 
**** What we gained?
Customizes the render method with which object should be created, enabling the superclass to implement it.
The render method calls this, similar to how a Template method calls methods, but since this is the only step customized in render, I don't consider render a template method. 
**** Consequences
The decal decorators, and dynamic decals, don't have a visitor to return, and thus, have to return null. This is bad. 

*** Visiter
**** The Shape Visitor used by Composite Layout
***** Why we used?
A composite layout has some shape, but doesn't know what shape, nor should it!. 
It also shouldn't know how to position things inside a shape.
Instead, the visiter is accepted by the shape, and thus knows what shape it has, and can then properly place items.
***** What we gained?
The composite layout need not know how to position things inside a shape, but still can.
***** Consequences
Visiter can get unwieldy, and a bit confusing.
If we add a new shape, all visiters need be updated.
**** The Shape Visitor used by Decal 
***** Why we used?
A Decal knows what it has that represents some visual thing, an image, text, or shape, but not how to render it in a circle, rectangle, or other shape, or even what shape it has.
That is left to the visiter to determine, and do the rendering.
***** What we gained?
Decal don't care about what shape they are told to render in, just make their visiter, and have the visiter visit and render in that shape. 
***** Consequences
A visiter for each DecalWithFM implementor.
If we add a new shape, all visiters need be updated.

*** Decorator
**** Why we used?
We found that we wanted to do certain actions to decals, that would result in new decals be added.
Cropping an image, masking an image, rotating an image, etc.
Rather than making these as new decals, which would cause a class explosion, and be limited only to the pairs we made, we decided that it makes sense to crop/rotate/mask any decal, and made these actions decal decorators. 

**** What we gained?
We can do basic image manipulation by chaining decorator decals, and then using those decorators like normal decals. 
**** Conseqences
Potentially inefficient. 



*** Composite
**** Why we used?
Our team decided to uses the Composite pattern because it offers an easy way to represent hierarchies and also it offers an easy way to treat individual objects and composite objects the same way. Our system allows for a layout component to have layouts or simpler objects such as decal.
**** What we gained?
- Easy way to represent hierarchies of objects.
- Easy way to nest composed and simple objects, inside one another.
- We can treat individual and composed objects the same way.
**** Consequences
- It makes it easier to represent layouts and decals. 
- It makes it easier to access the elements nested inside one another.
- It would be easier to add different types of decal, which are not defined right now.
- The design looks general.
*** Iterator
**** Why we used?
We decide to use this in order to allow an easy and simple way to access all the elements that will be used to represent a card object.
**** What we gained?
- A way to access the components without exposing its internal representation.
- We could support different traversal algorithms, but we only need one.
- It provides a uniform interface even for different structures.
**** Consequences
- No bad consequences on using the iterator patterns.
*** Proxy
**** Why we used?
Proxy pattern is used very lightly and only just one part of it. It is being used in the DynamicDecal class. The Dynamic Decal is the RealSubject, which will carry (execute) the request forwarded to it. The request would be to receive a decal given a string.
**** What we gained?
- We have the ability to indirectly reference to the Dycamin Decal class and retrieve something from it.
**** Consequences
- No consequences as a result of using this pattern.
*** Adapter
**** Why we used?
The adapter pattern is used for our Image class. Our image class will not be able to directly conform to the Image interface provided by the Java libraries. Therefore, we need to create a JavaImageAdapter class to adapt the interface we want with the interface we have.
**** What we gained?
- Ability to use an Image object, which behaves similar to the one used in Java libraries.
**** Consequences
- No bad consequences by using this design pattern.


* Driver System

The builders are loaded from an xml file, which as a name, and path to each visiter to be loaded.
** Strategy Pattern
The OutputFormat enum, and Output use the strategy pattern, with each being the strategy, and context, respectively.
Since an output shouldn't be burdened with every possible output format in a switch statement or something.
We want to be able to easily add more formats, and to avoid the Output class being bloated.
Thus, the output class will delegate converting image into the correct output format, and then writing that to disk, to the enum it holds. 
** Driver Class
- *Purpose:* 
The Driver will be the first thing the program will call and it will invoke all the other functions. In essence the Driver is our main.
- *Interaction:*  
The Driver will first call the Options class and parse through the config file. Afterwards the Driver will make the scriptEvaluator which will keep track of the script directory and make the appropriate Lexor. The evaluator will then use all the tokens outputted from the Lexor, throw it through the Builder Factory and construct the appropriate objects. In the end the evaluator returns the rendered cards to the Driver, who sends it to the Output class for it to be written and saved.

Will also load any builders requested to be loaded, and place them in the ScriptEvaluators environment.
- *Design Patterns it belongs:*
No design patterns used in it.



** Logger Class
- *Purpose:* 
The purpose of the Logger is to keep track of any errors found when parsing through the files and constructing the objects. The Logger will exit out of the program and output the list of errors when checked.
- *Interaction:*  
The errors will be added to the Logger when errors are found when contructing objects in the different builders. When the driver checks to see if there are any errors, the Logger will exit the program and output the appropriate errors.
- *Design Patterns it belongs:*
The Logger class used the singleton design pattern. We don't need multiple instances and its helpful because we are able to encapsulate the sole instance of the Logger class and have strict control on adding and checking errors.

** Options Class
- *Purpose:* 
Is to keep track of different variables of the deck found in the config file, such as input/output/logger directories or card output  types(png, jpg...).
- *Interaction:*  
Is created in the driver after parsing the config file. Its also used by the logger and output class both use the options class for knowing where to write to. 
- *Design Patterns it belongs:*
No design patterns used in it.

** Output Class
- *Purpose:* 
Where all the cards in the deck are written to.
- *Interaction:*  
The Driver will create the ouput class after evaluating the script, based on the options class. This is where all the cards will be written to after they are all created.
- *Design Patterns it belongs:*
No design patterns used in it.

* ScriptEvaluator system 
This includes all the Builders, and the Lexer. Whenever I say Builders, I mean subclasses of ScriptObjectBuilder.

** Basic Number manipulation
Basic number manipulation is provided by the NumberOperationBuilder, which is paramaterized with a command.
A builder for each command should be mapped with the appropriate symbol in the environment, with the rest of the builders.
** Builder
*** Why we used?
We have a ScriptObject which needs to be constructed, but the script objects vary quite a bit, and are all constructed differently. 
We can however, use a same general process, of first determining what to make, followed by the arguments given.
Thus, we can use a builder to separate the actual construction and representation from the construction process.
The builder itself knows what to do from the parameters given, and the tokens return the correct builder.
The ScriptEvaluator then can run the same process for each builder to receive the script object result.

This process will look something like this. 
In the ScriptEvaluatorImp
#+BEGIN_SRC java
ScriptObject doParse(Token token) {
    Builder builder = token.getBuilder(this);
        
    for (Token arg : token.getArgumentTokens()) {
        builder.addToken(this);
    }
    ScriptObject obj = builder.getResult();

    return obj;
}
#+END_SRC
Builder will define addToken something like this.
#+BEGIN_SRC java
void addToken(Token token) {
    ScriptObject obj = eval.doParse(token);
    obj.accept(this);

}
//This will be overriden by some builders!
#+END_SRC

The Builder itself is only dependent on the ScriptEvaluator, which contains the minimium operations needed for the language. 

The ScriptEvaluator serves as the Director. The implementor, CardLispScriptEvaluator, could potentially be replaced with a different one, allowing the same builders to be used with a different language.

Most, however, do not actually need it.
One could simply give a null ScriptObjectEvaluator to those that do not need it. 
One could also make a constructor that automatically does this, to avoid the programmer having to worry or possibly just split the ScriptObjectBuilder. 
One can keep the existing base, but add another subclass, and give that one the ScriptEvaluator.
Then, only the Builders that need it would have it.
If the dependency on the ScriptEvaluator was removed for some builders, it would help for standalone use, but for parsing a script, we wouldn't know when to make a Script object. We would then need a builder that requires a ScriptEvaluator reference.
Transparency would be lost either way, and it doesn't make sense to try to build ScriptObjects outside the script.

**** To Summarize
The builders can be used with a variety of languages, and some could be used anywhere, although doing so would cost some transparency.
They effectively isolate building objects from the rest of the scripting language, and allow a uniform process to create them all.
They enable easily changing the construction process for a new object, and adding new builders that can be used to add new language features.


*** What we gained?
- Ability to easily change how a certain object is constructed, by just replacing the builder.
- The same process can be used to construct all ScriptObjectBuilders.
- Can add new products by adding new builders.
*** Consequences
- Lots of builder classes, complicated design. 
- Builder might be overkill for some simple objects constructed.
- Builder has access to script evaluator, which is needed for construction, but adds some coupling.
  - Evaluator has a larger interface than it should to allow this coupling with the builders.
*** Where used
In the ScriptObjectBuilder, and subclasses

** Visitor
*** Why we used?
Needed to perform various operations across the various forms of ScriptObjects, both for rendering, and to construct ScriptObjects that contain ScriptObjects. 
Avoids need to cast when retrieving a ScriptObject from the environment, the ScriptObject tells the visiter what is being added. 
*** What we gained?
- Ability to avoid casting when adding parameters, and retrieving variables from the environment.
*** Consequences
- Must modify the ScriptObjectBuilder class for each new ScriptObject made
  - However, since there is a default for adding, that is, to forward to addScriptObject for an unexpected/unneeded type, only the concrete builders that need to deal with this new type need to be modified. So in practice, this is not a big problem.
- Visitor has a lot of methods, potentially a lot to inherit.
  
*** Where used
In the ScriptObjectBuilder, and subclasses.
** Command
*** Where used?
Number Operation Builder
*** Why we used?
Basic number manipulation can be done with some opertation being applied to two numbers, resulting in a third.
Some operations could be division, adition, etc.
To make a whole new builder for each one would be a class explosion, so instead, we paramaterize the builder with the correct number operation.
*** Consequences
- Only one builder is needed to handle any number operation of the form a <some operation> b = c.
- Extra indirection than a hardcoded method, slightly slower, could potentially be slightly harder to follow, won't know immediately what builder does.
- The Builder is paramatized with some number command to run upon creating a number value. 
  

** State ( Builders )
*** Why we used?
Most of the  ScruptObjectBuilder concrete subclassess change what they do depending on what arguments are given in. Generally they need to choose how to create the thing they are supposed to build, based on arguments are given in. There are some cases where a builder might choose between a few different, but similar, concrete class based on the arguments. And some other of the ScriptObjects are only valid if certain arguments are given, and until then, the context doesn't know if valid arguments were given!

This results in a context that needs to mantain its state, and change what it does based on what arguments have been given in.
The state pattern is an ideal fit for this.
Also, most builders have an error state they will go to if an invalid sequence of arguments occurs. 
*** What we gained?
- Builders isolate behavior in state.
  - No need for conditional logic to check what should be done, states handle this.
*** Consequences
- Many of the context (Builders) have to provide numerous extra operations to support the tight coupling between the two, some of which potentially violate state.
  - However, since the Builders will almost always be treated as their super class, ScriptObjectBuilder, which has a much tighter interface, this is a non-issue. 
  - Additionally, since the states are to be implemented as inner classes, these operations need not be part of the public interface, again making it a non-issue. 

    
** FactoryMethod 
*** Usage A
**** Where used
\newline 
In the ScriptEvalutor interface, getLexer.
Returns a implementor of the Lexer interface. 

While right now there is only one Lexer implementor, if another language were added, this would change.

**** Why?
\newline
If another language is added, then we will want to ensure we are using the correct scripting lexer for it.
This ensures that with the parallel type hierarchy, the correct lexer and ScriptEvaluator are used.
Since it is just a pair, an abstract factory is overkill, a single method will do.
*** Usage B
**** Where Used
\newline
In the ShapeDecalBuilder, to get the correct state to go to, after getting a color.
Since all shapes start with needing to get a color, but then go to some state specific state, depending on what specific subclass of ShapeBuilder it is, this is used to tie those paralell hierarchies together, and get the correct state. 
**** Why?
\newline
Two paralell hierarchies, the  ShapeBuilder subclasses, and their initial states.
Since these are designed to work together, the factory method works perfectly here.
    
** Adapter (String/Double wrappers are tailored object adapters)
*** Why we used?
The Scripting language contains two types of Atom literals. These are numbers (doubles), and strings. 
We want to use Java's built in String and double type, but those can't be aggregated with the rest of the ScriptObjects. String could potentially be stored as common type Object, but then we'd lose the ScriptObject specific stuff. Double could be boxed in Double, and then stored as object, but the same issue arises.
The solution is to make tailored object adapters, one for each type.
They each have just one operation to adapt, which is to get the value.
This lets the double and String be used with the rest of the ScriptObjects in the system.
*** What we gained?
Double, and String can now be used with their Adapters as if they were any other ScriptObject subtype.
*** Consequences
- Inefficiency of an extra object, and an extra reference to follow.

** Protection Proxy (String/Double wrappers)
*** Why we used?
These are constant values, they shouldn't be changed. (If set was added, then this would change, and we would need to add a set method to the proxies. This would still be good, as it would ensure the objects can only be changed one way.)

*** What we gained?
- String/Double ScriptObjects cannot be changed, and if that changes, it will be through one easily monitorable point.
*** Consequences
- Inefficiency of an extra object, and an extra reference to follow.

  
** ScriptEvaluator and the Facade Patter
The ScriptEvaluator was originally going to just be a Facade. 
The ScriptObjectBuilder subclasses would be fine to use without it, and could be used separately on tokens.
However, as the Environment got more complicated, and a current working directory path was needed, the ScriptObject became coupled with the Builders. 
A possible redesign would be to make a data interface, which all the Builders would be dependendent on, which could then enable the ScriptEvaluator to just be a Facade. However, I do not think that much would be gained from this, and while it is a fairly easy change to make, it is probably not worth the effort.
A more worthwhile Facade could be to make something that takes in a file path, runs the Lexer on it, then the ScriptEvaluator, but this would still be a fairly minor thing.

This being a fairly minor thing is the main reason I believe this not being a Facade is not a problem. The things it is doing are fairly simple. While it is interacting with a complex subsystem, the interactions are fairly simple.


** Composite for ScriptObject and Token
*** ScriptObject
ScriptObject and Token both feature recursive composition. 
However, for the ScriptObject, this is limited to just a few special cases, and the ScriptObject has no child management operations. 
Additionally, it's intent is not to represent part-whole hierarchies, or to let clients treat individuals/collections uniformly.
It's intention is to provide a common type, with some common functionality for all objects that exist in the scripting language. Then, code can interact with these objects, and only know that it is some object from the scripting language, but not care exactly what it is.
 - Not Composite pattern
*** Token
The Token features an ExpressionToken, which can have other tokens as arguments, and these can be further expression tokens. The rest of the Tokens are leaves.
The Token type also contains basic child management, in the form of getting the list of arguments as tokens.
Leaf tokens return an empty list. 
The intent is to enable an expression to be treated the same, regardless of whether it is a simple literal, a simple expression, or a bunch of sub expressions. 
- This is an example of composite pattern
**** Why we used?
Used to enable expression tokens to be made up of subexpressions, and for any piece of an expression to be treated the same when iterating through it, regardless of if it is a Variable, Expression, or Atom literal.
**** What we gained?
- ScriptEvaluator is simple, it does a simple iteration through the tokens. 
- When designing, was able to fairly easily split the original AtomToken into two subclasses, which fit better. Flexibility in adding Token types. 
- Tokens are similar to existing textual structure of language, easy to parse into tokens.
**** Consequences
- The getArguments() is unneeded for most tokens, which are leaves
  - But at least well defined, it's just empty!

** Prototype (Builders)
*** Why we used?
Some of the Builders are paramterized and configured. (The FunctionBuilder is the main one).
Additionally, need a way to get a new instance of the correct builders.
One option is to store class objects, or a giant conditional statement for each builder.
The latter hard codes them, and makes it hard to add dynamically (needed for FunctionBuilder), and both don't allow builders that have been configured to be stored.

While the FunctionBuilder is the main one that needs to store the FunctionBody and arguments it is given and stored with, it allows flexibility for future builders.
For example, a number operation builder might have one concrete builder class, that takes in the operation to do, +,-,/,*,etc, and then store that builder paramaterized with each operation as a prototype.

*** Implementation note
Most of the builders are easy to clone. 
They are stored with their freshly constructed state, and don't have much to share.
They can share the initial state, but upon changing state, the clone will get it's own.
The only condition is that any change to the clone shouldn't effect the original.
Lists should be cloned, but items don't need to be deep copied. 
ScriptObjects can be shared, as they are not changed after being constructed.
(If the builder has the object it is constructing, and thus changing, then it should either set a new one, or deep copy it on clone.)
Since Tokens are not changed, the FunctionBuilder can share these.
*** What we gained?
- Can store Builders in the factory easily, and retrieve them via cloning.
- Can change a builder to change an operation, and then store it under a new name, essentially adding a builder to the system.
*** Consequences
- Clone adds some complications.
  - Need to be careful of what can be shared, what must be deep copied. 
** Abstract Factory with Prototypes
*** Why we used?
*** What we gained?
- Enabled tokens to easily retrieve the Builder they need.
- To be able to store the Builders created for defined functions, and retrieve them as if they were the predefined Builders.
- To lessen hard-coding Builder types in tokens.
- Provide a central repository of the builder prototype. 
*** Consequences
- Memory consequence, Builder prototypes use memory in the map.
- String comparisons can be more expensive time-wise than hard-coded class instances. 

** Lexer
*** Purpose
To take an input file, and return a list of tokens. 

To add support for additional scripting language, provided that the language can be represented with the existing tokens.
To do this, one must make a new implementor of the interface, and a corresponding ScriptEvaluator implementor.


*** UML
file:Structure/LexerUML.png
*** Token
- Tokens are immutable after creation.
**** Types
***** VariableToken
- Leaf token, holds a variable name.
- Returns a VariableBuilderVisitor, with either an UndefinedVariable object if variable is not found, or the variable if it is found in the environment variables. 
***** AtomToken
- Returns a ConstantBuilderVisitor with the value wrapped in an appropriate ScriptObject. 
****** StringAtomToken
- Leaf token, holds a string.
****** DoubleAtomToken
- Leaf token, holds a double.
***** ParseErrorToken
- Leaf token, represents an error that occured during parsing.
- Returns a ConstantBuilderVisiter, with an ErrorScriptObject as the value.
***** ExpressionToken
- The composite of the layouts.
  - Holds other tokens, they are the arguments given to the expression.
  - Holds the name of the function invoked.
- Looks for its builder in the environment.
  - If found, return it!
  - If none found, then make an UndefinedFunctionBuilder.
    - If ExpressionToken is composed only of variables, then return UndefinedFunctionBuilder with the given parameter names and function name. 
      - If the result of this Builder is an UndefinedFunction script object, and is given to a DefineBuilder as the first argument, that DefineBuilder will then define the UndefinedFunction in the environment variables, so next time the function name is looked up, it will be found in the environment!
    - Else, return an UndefinedFunctionBuilder with an ErrorScriptObject. 
**** Purpose
- To represent a the language in objects, rather than plain text.
- That logic can be put in one place, the lexer.
- Each token then knows what it is, and knows what builder to get. 
- This separates the text representation of the scripting language from the objects it creates.

** ScriptEvaluator 
*** Environment Subsystem
**** Environment 
- An environment frame.
- Holds a map of strings to defined variables, and a BuilderFactory.
**** EnvrionmentList
- The Environments for the language.
- Contains a list of Environments, and operations to check from the most recently defined to the original, global env if a variable, or builder is defined.
- Can also manage and remove environments. 
- Calling a function will add a frame to this, exiting a function removes said frame.
**** BuilderFactory
- Holds the builder prototypes in a map. 
- Can add and retrieve them from the map. 

*** Builder subsystem
The meat of this system.
ScriptObjectBuilder has numerous concrete builders.
Generally, one for each ScriptObject subclass. 
- See the UML for a complete list.
The goal of these builders is to know how to construct a ScriptObject. 
Adding a new object just requires adding a new builder for it, and then adding a new method.
Only the appropriate subclass Builders need to care about said new ScriptObject. Unlike with the usual Visitor pattern, not all the Builder Visitors need to be updated. 

- They encapsulate building a script object.

- See the Builder section earlier for more info.

*** RenderedCard
A simple "Plain Old Data" class, holds the rendered images of the card along with its name.


** Interactions
The ScriptEvaluator implementor is what will iterate through the tokens, and run the constructor process on the builder.
The driver gets a Lexer from said implementor, and then uses that lexer to make Tokens.
The driver then uses the ScriptEvaluator to evaluate those tokens. 
The tokens know what builder to make, and may do some small configuration to it. 
Then the builders get directed, as said above. 
When all the tokens are finished, the driver will retrieve the rendered cards.

*** CardRepresentation system and Decal interactions
- The ScriptEvaluator interacts with the CardRepresentation and Decals fairly heavily.
  - The builders create decals, and place them in leaf-layouts.
  - The builders create and assemble layouts.
  - The builders create cards and give them layouts.
  - The builders create families.
  - Render will call "render" on a card, with the given families.
    - After doing this, the result will be stored.
  - All objects defined are stored in the environment of the ScriptEvaluator.
** Note on Lexer + ScriptEvaluator interfaces
- Parallel hierarchy!
- For each language supported, there will be a ScriptEvaluator and Lexer implementor pair for it!

